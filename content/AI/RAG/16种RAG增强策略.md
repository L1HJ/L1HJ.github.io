
| 编号  | 名称                         | 核心假设/改进思路                | 得分    | 实现难度       | 推荐理由                       |
| --- | -------------------------- | ------------------------ | ----- | ---------- | -------------------------- |
| 1   | Simple RAG                 | 将多个文档直接按固定长度且分为多个chunk   | 0.3   | 🌟         | 实现简单，适用于初步尝试或小规模项目         |
| 2   | Semantic Chunking          | 按照语义单元进行分块，避免断章取义        | 0.2   | 🌟🌟       | 提升语义完整性，适合需要理解上下文的任务       |
| 3   | Context Enriched Retrieval | 在检索时考虑更多上下文信息，提高相关性      | 0.6   | 🌟🌟🌟     | 提高检索结果的相关性和准确性             |
| 4   | Contextual Augmentation    | 为每个chunk添加描述性标题，提供额外线索   | 0.5   | 🌟🌟       | 增强chunk的可理解性，便于模型判断        |
| 5   | Document Augmentation      | 自动补充文档中的关键信息，丰富表达        | 0.8   | 🌟🌟🌟     | 扩展知识入口，提高命中率               |
| 6   | Query Transformation       | 对原始查询进行改写，增强语义表达         | 0.5   | 🌟🌟       | 提升检索多样性，成本低见效快             |
| 7   | Rerank                     | 使用更精细模型对初筛结果重新打分排序       | 0.7   | 🌟🌟🌟     | 提升最相关chunk的排名，是高质量RAG的标配模块 |
| 8   | RSE                        | 通过上下文窗口扩展检索范围，处理跨chunk问题 | 0.8   | 🌟🌟🌟🌟   | 更好处理复杂问题，提升整体匹配效果          |
| 9   | Feedback Loop              | 用户反馈能持续优化系统性能            | 0.7   | 🌟🌟🌟🌟🌟 | 系统具体自我进化能力，适合长期运营          |
| 10  | Adaptive RAG               | 不同查询类型影采用不同策略和知识来源       | 0.86  | 🌟🌟🌟🌟   | 最灵活、最智能的RAG架构，适用于复杂业务场景    |
| 11  | Self RAG                   | 模型自主筛选高相关性内容，减少噪音        | 0.6   | 🌟🌟🌟🌟   | 提升生成准确性，具备“判断力”            |
| 12  | Knowledge Graph            | 利用图结构表达信息间的语义关系          | 0.78  | 🌟🌟🌟🌟🌟 | 强大的语义结构化工具，适合深度推理任务        |
| 13  | Hierarchical Indices       | 结合小块精准和大块上下文优势           | 0.84  | 🌟🌟🌟🌟   | 在精度与上下文之间取得最佳平衡            |
| 14  | HYDE                       | 先生成假设答案再检索，弥补表达差异        | 0.5   | 🌟🌟🌟     | 适合模糊表达类问题，提升召回率            |
| 15  | Fusion                     | 结合向量 + 关键词检索，减少漏检        | 0.83  | 🌟🌟🌟     | 结合语义与关键词双重优势，提升检索效果        |
| 16  | CRAG                       | 评估并修正检索结果中的错误信息          | 0.824 | 🌟🌟🌟🌟   | 显著提升准确性与系统可信度              |

## Semantic Chunking


## Context Enriched Retrieval


## Document Augmentation



## Query Transformation


## Reranker


## RSE(Re-ranking with Semantic Expansion)

## RSE 核心流程

### Step 1：固定切分 & 向量化入库
### Step 2：初步检索 & 过滤高相似度片段
### Step 3：基于上下文窗口的连续片段查找
### Step 4：返回最终上下文组作为生成依据



## Feedback Loop




## Adaptive RAG
---
### 什么是 Adaptive RAG
1. 定义
	Adaptive RAG 是一种根据用户查询类型、意图或复杂程度，动态选择不同检索策略、模型配置和知识库来源的RAG架构。
2. 核心思想
	- 查询不是单一类型的；
	- 检索不应“一刀切”；
	- 根据不同场景，使用最合适的方法组合来获取最佳结果
---
### 为什么需要Adaptive RAG

| 问题      | 描述                      |
| ------- | ----------------------- |
| 固定策略检索  | 所有查询都走同一套流程，效率低且效果不稳定   |
| 多样化用户需求 | 包括事实性问题、解释性问题、推理类问题等    |
| 多源异构知识  | 来源数据库、PDF、网页、表格、代码等多种格式 |
| 模型能力差异  | LLM对不同类型任务的表现不同         |

---
### Adaptive RAG 核心流程

#### Step 1：Query Type Detection

| 类型            | 描述    | 示例                |
| ------------- | ----- | ----------------- |
| Fact-based    | 事实性问题 | “故宫建于哪个朝代？”       |
| Exploratory   | 探索性问题 | “北京有哪些值得一去的地方？”   |
| Comparative   | 比较类问题 | “故宫和卢浮宫有什么区别？”    |
| Instructional | 操作指导类 | “如何预约故宫门票？”       |
| Multi-hop     | 多跳推理类 | “故宫建成后经历了哪些重大事件？” |

#### Step 2：根据类型选择检索策略

| 查询类型          | 检索策略               |
| ------------- | ------------------ |
| Fact-based    | 精确关键词检索 + Rerank   |
| Exploratory   | 语义扩展检索 + 上下文增强     |
| Comparative   | 多文档对比 + 双向Chunk匹配  |
| Instructional | 结构化数据优先（如表格、FAQ）   |
| Multi-hop     | 多阶段检索 + RSE（上下文扩展） |

#### Step 3：选择合适的知识库或数据源

#### Step 4：调用合适的模型与生成逻辑

| 查询类型          | 推荐配置              |
| ------------- | ----------------- |
| Fact-based    | 小模型快速回答，减少延迟      |
| Exploratory   | 大模型 + 上下文窗口扩展     |
| Comparative   | 对比式prompt + 分析性输出 |
| Instructional | 步骤式生成 + 引导性语言     |
| Multi-hop     | 多轮检索 + 思维链        |


## Self RAG



## Knowledge Graph



## Hierarchical Indices（层次化索引）



## HyDE（Hypothetical Document Embedding，假设文档嵌入）



## Fusion（融合检索）



## CRAG（Corrective RAG）